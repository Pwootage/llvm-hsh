#ifndef HSH_TRAIT_TEMPLATE_PARMS
#define HSH_TRAIT_TEMPLATE_PARMS
#endif
#ifndef HSH_TRAIT_TEMPLATE_REFS
#define HSH_TRAIT_TEMPLATE_REFS
#endif
#ifdef HSH_TRAIT_BINDING
struct HSH_TRAIT_BINDING;
#endif
#ifdef HSH_MULTI_TRAIT
HSH_TRAIT_TEMPLATE_PARMS
union HSH_MULTI_TRAIT {
#ifdef HSH_TRAIT_OWNER
  using Owner = HSH_TRAIT_OWNER;
  HSH_MULTI_TRAIT(const Owner &Owner) {
     switch (ActiveTarget) {
#define HSH_ACTIVE_TARGET(Enumeration) case Enumeration: new (&_##Enumeration) decltype(_##Enumeration)(Owner._##Enumeration); break;
#include "targets.def"
    default:
      assert(false && "unhandled case");
    }
  }
#include "targets.def"
#endif
#ifdef HSH_TRAIT_BINDING
  using Binding = HSH_TRAIT_BINDING;
  operator Binding() const {
    switch (ActiveTarget) {
#define HSH_ACTIVE_TARGET(Enumeration) case Enumeration: return Binding(get_##Enumeration());
#include "targets.def"
    default:
      assert(false && "unhandled case");
      return Binding();
    }
  }
#endif
#define HSH_ACTIVE_TARGET(Enumeration) TargetTraits<Enumeration>::HSH_MULTI_TRAIT HSH_TRAIT_TEMPLATE_REFS _##Enumeration;
#include "targets.def"
  template <typename... Parms>
  HSH_MULTI_TRAIT(Parms&&... p) {
    switch (ActiveTarget) {
#define HSH_ACTIVE_TARGET(Enumeration) case Enumeration: new (&_##Enumeration) decltype(_##Enumeration)(std::forward<Parms>(p)...); break;
#include "targets.def"
    default:
      assert(false && "unhandled case");
    }
  }
  ~HSH_MULTI_TRAIT() {
    switch (ActiveTarget) {
#define HSH_ACTIVE_TARGET(Enumeration) case Enumeration: std::destroy_at(&_##Enumeration); break;
#include "targets.def"
    default:
      assert(false && "unhandled case");
    }
  }
  HSH_MULTI_TRAIT(const HSH_MULTI_TRAIT &other) {
    switch (ActiveTarget) {
#define HSH_ACTIVE_TARGET(Enumeration) case Enumeration: new (&_##Enumeration) decltype(_##Enumeration)(other._##Enumeration); break;
#include "targets.def"
    default:
      assert(false && "unhandled case");
    }
  }
  HSH_MULTI_TRAIT(HSH_MULTI_TRAIT &&other) {
    switch (ActiveTarget) {
#define HSH_ACTIVE_TARGET(Enumeration) case Enumeration: new (&_##Enumeration) decltype(_##Enumeration)(std::move(other._##Enumeration)); break;
#include "targets.def"
    default:
      assert(false && "unhandled case");
    }
  }
  HSH_MULTI_TRAIT &operator=(const HSH_MULTI_TRAIT &other) {
    switch (ActiveTarget) {
#define HSH_ACTIVE_TARGET(Enumeration) case Enumeration: _##Enumeration = other._##Enumeration; break;
#include "targets.def"
    default:
      assert(false && "unhandled case");
    }
    return *this;
  }
  HSH_MULTI_TRAIT &operator=(HSH_MULTI_TRAIT &&other) {
    switch (ActiveTarget) {
#define HSH_ACTIVE_TARGET(Enumeration) case Enumeration: _##Enumeration = std::move(other._##Enumeration); break;
#include "targets.def"
    default:
      assert(false && "unhandled case");
    }
    return *this;
  }
#define HSH_ACTIVE_TARGET(Enumeration) \
operator TargetTraits<Enumeration>::HSH_MULTI_TRAIT HSH_TRAIT_TEMPLATE_REFS &() { assert(ActiveTarget == Enumeration && "bad cast"); return _##Enumeration; } \
TargetTraits<Enumeration>::HSH_MULTI_TRAIT HSH_TRAIT_TEMPLATE_REFS &get_##Enumeration() { assert(ActiveTarget == Enumeration && "bad cast"); return _##Enumeration; } \
operator const TargetTraits<Enumeration>::HSH_MULTI_TRAIT HSH_TRAIT_TEMPLATE_REFS &() const { assert(ActiveTarget == Enumeration && "bad cast"); return _##Enumeration; } \
const TargetTraits<Enumeration>::HSH_MULTI_TRAIT HSH_TRAIT_TEMPLATE_REFS &get_##Enumeration() const { assert(ActiveTarget == Enumeration && "bad cast"); return _##Enumeration; }
#include "targets.def"
#ifdef HSH_DYNAMIC_OWNER
  void *map() {
    switch (ActiveTarget) {
#define HSH_ACTIVE_TARGET(Enumeration) case Enumeration: return _##Enumeration.map();
#include "targets.def"
    default:
      assert(false && "unhandled case");
      return nullptr;
    }
  }
  void unmap() {
    switch (ActiveTarget) {
#define HSH_ACTIVE_TARGET(Enumeration) case Enumeration: _##Enumeration.unmap(); break;
#include "targets.def"
    default:
      assert(false && "unhandled case");
    }
  }
#endif
};
#undef HSH_MULTI_TRAIT
#endif

#ifdef HSH_SINGLE_TRAIT
HSH_TRAIT_TEMPLATE_PARMS
struct HSH_SINGLE_TRAIT {
#ifdef HSH_TRAIT_OWNER
  using Owner = HSH_TRAIT_OWNER;
#define HSH_ACTIVE_TARGET(Enumeration) HSH_SINGLE_TRAIT(const Owner &Owner) : _##Enumeration(Owner._##Enumeration) {}
#include "targets.def"
#endif
#ifdef HSH_TRAIT_BINDING
  using Binding = HSH_TRAIT_BINDING;
  operator Binding() const {
#define HSH_ACTIVE_TARGET(Enumeration) return Binding(get_##Enumeration());
#include "targets.def"
  }
#endif
#define HSH_ACTIVE_TARGET(Enumeration) \
TargetTraits::HSH_SINGLE_TRAIT HSH_TRAIT_TEMPLATE_REFS _##Enumeration; \
template <typename... Parms> \
HSH_SINGLE_TRAIT(Parms&&... p) : _##Enumeration(std::forward<Parms>(p)...) {} \
operator TargetTraits::HSH_SINGLE_TRAIT HSH_TRAIT_TEMPLATE_REFS &() { return _##Enumeration; } \
TargetTraits::HSH_SINGLE_TRAIT HSH_TRAIT_TEMPLATE_REFS &get_##Enumeration() { return _##Enumeration; } \
operator const TargetTraits::HSH_SINGLE_TRAIT HSH_TRAIT_TEMPLATE_REFS &() const { return _##Enumeration; } \
const TargetTraits::HSH_SINGLE_TRAIT HSH_TRAIT_TEMPLATE_REFS &get_##Enumeration() const { return _##Enumeration; }
#include "targets.def"
#ifdef HSH_DYNAMIC_OWNER
#define HSH_ACTIVE_TARGET(Enumeration) \
void *map() { return _##Enumeration.map(); } \
void unmap() { _##Enumeration.unmap(); }
#include "targets.def"
#endif
  };
#undef HSH_SINGLE_TRAIT
#endif

#undef HSH_TRAIT_TEMPLATE_PARMS
#undef HSH_TRAIT_TEMPLATE_REFS
#undef HSH_TRAIT_OWNER
#undef HSH_TRAIT_BINDING
#undef HSH_DYNAMIC_OWNER

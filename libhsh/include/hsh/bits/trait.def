#ifndef HSH_TRAIT_TEMPLATE_PARMS
#define HSH_TRAIT_TEMPLATE_PARMS
#endif
#ifndef HSH_TRAIT_TEMPLATE_REFS
#define HSH_TRAIT_TEMPLATE_REFS
#endif
#ifdef HSH_TRAIT_BINDING
struct HSH_TRAIT_BINDING;
#endif
#ifdef HSH_RENDER_TEXTURE_OWNER
struct RenderTextureBinding;
#endif
#ifdef HSH_MULTI_TRAIT
HSH_TRAIT_TEMPLATE_PARMS
union HSH_MULTI_TRAIT {
#ifdef HSH_TRAIT_OWNER
  using Owner = HSH_TRAIT_OWNER;
  HSH_MULTI_TRAIT(const Owner &Owner) noexcept {
     switch (CurrentTarget) {
#define HSH_ACTIVE_TARGET(Enumeration) case Enumeration: new (&_##Enumeration) decltype(_##Enumeration)(Owner._##Enumeration); break;
#include "targets.def"
    default:
      assert(false && "unhandled case");
    }
  }
#include "targets.def"
#endif
#ifdef HSH_TRAIT_BINDING
  using Binding = HSH_TRAIT_BINDING;
  operator Binding() const noexcept {
    switch (CurrentTarget) {
#define HSH_ACTIVE_TARGET(Enumeration) case Target::Enumeration: return Binding(get_##Enumeration());
#include "targets.def"
    default:
      assert(false && "unhandled case");
      return Binding();
    }
  }
#endif
#define HSH_ACTIVE_TARGET(Enumeration) TargetTraits<Target::Enumeration>::HSH_MULTI_TRAIT HSH_TRAIT_TEMPLATE_REFS _##Enumeration;
#include "targets.def"
  template <typename... Parms>
  HSH_MULTI_TRAIT(Parms&&... p) noexcept {
    switch (CurrentTarget) {
#define HSH_ACTIVE_TARGET(Enumeration) case Target::Enumeration: new (&_##Enumeration) decltype(_##Enumeration)(std::forward<Parms>(p)...); break;
#include "targets.def"
    default:
      assert(false && "unhandled case");
    }
  }
  ~HSH_MULTI_TRAIT() noexcept {
    switch (CurrentTarget) {
#define HSH_ACTIVE_TARGET(Enumeration) case Target::Enumeration: std::destroy_at(&_##Enumeration); break;
#include "targets.def"
    default:
      assert(false && "unhandled case");
    }
  }
  HSH_MULTI_TRAIT(const HSH_MULTI_TRAIT &other) noexcept {
    switch (CurrentTarget) {
#define HSH_ACTIVE_TARGET(Enumeration) case Target::Enumeration: new (&_##Enumeration) decltype(_##Enumeration)(other._##Enumeration); break;
#include "targets.def"
    default:
      assert(false && "unhandled case");
    }
  }
  HSH_MULTI_TRAIT(HSH_MULTI_TRAIT &&other) noexcept {
    switch (CurrentTarget) {
#define HSH_ACTIVE_TARGET(Enumeration) case Target::Enumeration: new (&_##Enumeration) decltype(_##Enumeration)(std::move(other._##Enumeration)); break;
#include "targets.def"
    default:
      assert(false && "unhandled case");
    }
  }
  HSH_MULTI_TRAIT &operator=(const HSH_MULTI_TRAIT &other) noexcept {
    switch (CurrentTarget) {
#define HSH_ACTIVE_TARGET(Enumeration) case Target::Enumeration: _##Enumeration = other._##Enumeration; break;
#include "targets.def"
    default:
      assert(false && "unhandled case");
    }
    return *this;
  }
  HSH_MULTI_TRAIT &operator=(HSH_MULTI_TRAIT &&other) noexcept {
    switch (CurrentTarget) {
#define HSH_ACTIVE_TARGET(Enumeration) case Target::Enumeration: _##Enumeration = std::move(other._##Enumeration); break;
#include "targets.def"
    default:
      assert(false && "unhandled case");
    }
    return *this;
  }
  bool IsValid() const noexcept {
    switch (CurrentTarget) {
#define HSH_ACTIVE_TARGET(Enumeration) case Target::Enumeration: return _##Enumeration.IsValid();
#include "targets.def"
    default:
      assert(false && "unhandled case");
    }
    return false;
  }
#define HSH_ACTIVE_TARGET(Enumeration) \
operator TargetTraits<Target::Enumeration>::HSH_MULTI_TRAIT HSH_TRAIT_TEMPLATE_REFS &() noexcept { assert(CurrentTarget == Target::Enumeration && "bad cast"); return _##Enumeration; } \
TargetTraits<Target::Enumeration>::HSH_MULTI_TRAIT HSH_TRAIT_TEMPLATE_REFS &get_##Enumeration() noexcept { assert(CurrentTarget == Target::Enumeration && "bad cast"); return _##Enumeration; } \
operator const TargetTraits<Target::Enumeration>::HSH_MULTI_TRAIT HSH_TRAIT_TEMPLATE_REFS &() const noexcept { assert(CurrentTarget == Target::Enumeration && "bad cast"); return _##Enumeration; } \
const TargetTraits<Target::Enumeration>::HSH_MULTI_TRAIT HSH_TRAIT_TEMPLATE_REFS &get_##Enumeration() const noexcept { assert(CurrentTarget == Target::Enumeration && "bad cast"); return _##Enumeration; }
#include "targets.def"
#ifdef HSH_DYNAMIC_OWNER
  void *Map() noexcept {
    switch (CurrentTarget) {
#define HSH_ACTIVE_TARGET(Enumeration) case Target::Enumeration: return _##Enumeration.Map();
#include "targets.def"
    default:
      assert(false && "unhandled case");
      return nullptr;
    }
  }
  void Unmap() noexcept {
    switch (CurrentTarget) {
#define HSH_ACTIVE_TARGET(Enumeration) case Target::Enumeration: _##Enumeration.Unmap(); break;
#include "targets.def"
    default:
      assert(false && "unhandled case");
    }
  }
#endif
#ifdef HSH_RENDER_TEXTURE_OWNER
  RenderTextureBinding GetColor(uint32_t idx) const noexcept {
    switch (CurrentTarget) {
#define HSH_ACTIVE_TARGET(Enumeration) case Target::Enumeration: return _##Enumeration.GetColor(idx);
#include "targets.def"
    default:
      assert(false && "unhandled case");
      return {};
    }
  }
  RenderTextureBinding GetDepth(uint32_t idx) const noexcept {
    switch (CurrentTarget) {
#define HSH_ACTIVE_TARGET(Enumeration) case Target::Enumeration: return _##Enumeration.GetDepth(idx);
#include "targets.def"
    default:
      assert(false && "unhandled case");
      return {};
    }
  }
  void Attach() noexcept {
    switch (CurrentTarget) {
#define HSH_ACTIVE_TARGET(Enumeration) case Target::Enumeration: _##Enumeration.Attach(); break;
#include "targets.def"
    default:
      assert(false && "unhandled case");
    }
  }
  void ResolveSurface(SurfaceBinding surf, bool reattach) noexcept {
    switch (CurrentTarget) {
#define HSH_ACTIVE_TARGET(Enumeration) case Target::Enumeration: _##Enumeration.ResolveSurface(surf, reattach); break;
#include "targets.def"
    default:
      assert(false && "unhandled case");
    }
  }
  void ResolveColorBinding(uint32_t idx, rect2d region, bool reattach) noexcept {
    switch (CurrentTarget) {
#define HSH_ACTIVE_TARGET(Enumeration) case Target::Enumeration: _##Enumeration.ResolveColorBinding(idx, region, reattach); break;
#include "targets.def"
    default:
      assert(false && "unhandled case");
    }
  }
  void ResolveDepthBinding(uint32_t idx, rect2d region, bool reattach) noexcept {
    switch (CurrentTarget) {
#define HSH_ACTIVE_TARGET(Enumeration) case Target::Enumeration: _##Enumeration.ResolveDepthBinding(idx, region, reattach); break;
#include "targets.def"
    default:
      assert(false && "unhandled case");
    }
  }
#endif
#ifdef HSH_SURFACE_OWNER
  bool AcquireNextImage() noexcept {
    switch (CurrentTarget) {
#define HSH_ACTIVE_TARGET(Enumeration) case Target::Enumeration: return _##Enumeration.AcquireNextImage();
#include "targets.def"
    default:
      assert(false && "unhandled case");
      return false;
    }
  }
#endif
#ifdef HSH_PIPELINE_BINDING
  void Draw(uint32_t start, uint32_t count) noexcept {
    switch (CurrentTarget) {
#define HSH_ACTIVE_TARGET(Enumeration) case Target::Enumeration: _##Enumeration.Draw(start, count); break;
#include "targets.def"
    default:
      assert(false && "unhandled case");
    }
  }
#endif
};
#undef HSH_MULTI_TRAIT
#endif

#ifdef HSH_SINGLE_TRAIT
HSH_TRAIT_TEMPLATE_PARMS
struct HSH_SINGLE_TRAIT {
#ifdef HSH_TRAIT_OWNER
  using Owner = HSH_TRAIT_OWNER;
#define HSH_ACTIVE_TARGET(Enumeration) HSH_SINGLE_TRAIT(const Owner &Owner) noexcept : _##Enumeration(Owner._##Enumeration) {}
#include "targets.def"
#endif
#ifdef HSH_TRAIT_BINDING
  using Binding = HSH_TRAIT_BINDING;
  operator Binding() const noexcept {
#define HSH_ACTIVE_TARGET(Enumeration) return Binding(get_##Enumeration());
#include "targets.def"
  }
#endif
#define HSH_ACTIVE_TARGET(Enumeration) \
TargetTraits::HSH_SINGLE_TRAIT HSH_TRAIT_TEMPLATE_REFS _##Enumeration; \
template <typename... Parms> \
HSH_SINGLE_TRAIT(Parms&&... p) noexcept : _##Enumeration(std::forward<Parms>(p)...) {} \
operator TargetTraits::HSH_SINGLE_TRAIT HSH_TRAIT_TEMPLATE_REFS &() noexcept { return _##Enumeration; } \
TargetTraits::HSH_SINGLE_TRAIT HSH_TRAIT_TEMPLATE_REFS &get_##Enumeration() noexcept { return _##Enumeration; } \
operator const TargetTraits::HSH_SINGLE_TRAIT HSH_TRAIT_TEMPLATE_REFS &() const noexcept { return _##Enumeration; } \
const TargetTraits::HSH_SINGLE_TRAIT HSH_TRAIT_TEMPLATE_REFS &get_##Enumeration() const noexcept { return _##Enumeration; } \
bool IsValid() const noexcept { return _##Enumeration.IsValid(); }
#include "targets.def"
#ifdef HSH_DYNAMIC_OWNER
#define HSH_ACTIVE_TARGET(Enumeration) \
void *Map() noexcept { return _##Enumeration.Map(); } \
void Unmap() noexcept { _##Enumeration.Unmap(); }
#include "targets.def"
#endif
#ifdef HSH_RENDER_TEXTURE_OWNER
#define HSH_ACTIVE_TARGET(Enumeration) \
RenderTextureBinding GetColor(uint32_t idx) const noexcept { return _##Enumeration.GetColor(idx); } \
RenderTextureBinding GetDepth(uint32_t idx) const noexcept { return _##Enumeration.GetDepth(idx); } \
void Attach() noexcept { _##Enumeration.Attach(); } \
void ResolveSurface(SurfaceBinding surf, bool reattach) noexcept { _##Enumeration.ResolveSurface(surf, reattach); } \
void ResolveColorBinding(uint32_t idx, rect2d region, bool reattach) noexcept { _##Enumeration.ResolveColorBinding(idx, region, reattach); } \
void ResolveDepthBinding(uint32_t idx, rect2d region, bool reattach) noexcept { _##Enumeration.ResolveDepthBinding(idx, region, reattach); }
#include "targets.def"
#endif
#ifdef HSH_SURFACE_OWNER
#define HSH_ACTIVE_TARGET(Enumeration) \
bool AcquireNextImage() noexcept { return _##Enumeration.AcquireNextImage(); }
#include "targets.def"
#endif
#ifdef HSH_PIPELINE_BINDING
#define HSH_ACTIVE_TARGET(Enumeration) \
void Draw(uint32_t start, uint32_t count) noexcept { _##Enumeration.Draw(start, count); }
#include "targets.def"
#endif
  };
#undef HSH_SINGLE_TRAIT
#endif

#undef HSH_TRAIT_TEMPLATE_PARMS
#undef HSH_TRAIT_TEMPLATE_REFS
#undef HSH_TRAIT_OWNER
#undef HSH_TRAIT_BINDING
#undef HSH_DYNAMIC_OWNER
#undef HSH_RENDER_TEXTURE_OWNER
#undef HSH_SURFACE_OWNER
#undef HSH_PIPELINE_BINDING
